{% load static %}
// sw.js - Service Worker para PWA
// {% now "Y-m-d H:i:s" %}
// Permite funcionamiento offline y caché de recursos

const CACHE_NAME = '{{ cache_name|default:"geoqr-v2" }}';
const DEBUG = {{ debug|lower }};

/**
 * Maneja errores de solicitud (offline, servidor caído, etc.)
 * @param {Request} request - La solicitud HTTP que falló
 * @returns {Promise<Response>} - Respuesta cacheada o página de error
 */
function handleRequestError(request) {
  // Si es una solicitud de documento (página HTML)
  if (request.destination === 'document') {
    // Verificar si es verdaderamente offline (sin conexión de red)
    if (!navigator.onLine) {
      if (DEBUG) console.log('Service Worker: Usuario offline');
      
      // Intentar obtener página offline en caché
      return caches.match('/offline.html')
        .then(cachedPage => {
          if (cachedPage) {
            notifyClients({
              type: 'OFFLINE',
              message: 'No hay conexión a internet. Mostrando página en caché.'
            });
            return cachedPage;
          }
          
          // Si no está en caché, retornar respuesta de error simple
          if (DEBUG) console.error('Service Worker: /offline.html no está en caché');
          return new Response('Sin conexión. Por favor, intenta más tarde.', {
            status: 503,
            statusText: 'Service Unavailable',
            headers: { 'Content-Type': 'text/plain; charset=utf-8' }
          });
        });
    } else {
      // Hay conexión pero no se pudo alcanzar el servidor
      if (DEBUG) console.log('Service Worker: Servidor no disponible (hay conexión)');
      
      // Intentar obtener página de error en caché
      return caches.match('/server-error.html')
        .then(errorPage => {
          if (errorPage) {
            notifyClients({
              type: 'SERVER_ERROR',
              message: 'El servidor no está disponible. Mostrando página en caché.'
            });
            return errorPage;
          }
          
          // Si no está en caché, retornar respuesta de error simple
          if (DEBUG) console.error('Service Worker: /server-error.html no está en caché');
          return new Response('Servidor no disponible. Por favor, intenta más tarde.', {
            status: 503,
            statusText: 'Service Unavailable',
            headers: { 'Content-Type': 'text/plain; charset=utf-8' }
          });
        });
    }
  }
  
  // Para otros tipos de solicitud (API, recursos), retornar undefined
  return Promise.resolve(undefined);
}

/**
 * Notifica a todos los clientes (ventanas/tabs) sobre eventos del Service Worker
 * @param {Object} message - Objeto con información del evento
 */
function notifyClients(message) {
  self.clients.matchAll({ type: 'window' }).then(clients => {
    clients.forEach(client => {
      client.postMessage({
        from: 'ServiceWorker',
        timestamp: new Date().toISOString(),
        ...message
      });
    });
  }).catch(err => {
    if (DEBUG) console.warn('Service Worker: Error al notificar clientes', err);
  });
}


const urlsToCache = [
  // Páginas principales
  // '/',
  
  // Páginas de error (críticas para funcionar offline)
  '/offline.html',
  '/server-error.html',
  
  // Archivos estáticos
  '{% static "manifest.json" %}',
  '{% static "fallback.css" %}',
  '{% static "app.js" %}',
  
  // Fuentes y librerías externas
  'https://cdn.tailwindcss.com',
  'https://unpkg.com/htmx.org@2.0.0',
  'https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js',
  'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap'
];

// Instalación del Service Worker
self.addEventListener('install', (event) => {
  if (DEBUG) console.log('Service Worker: Instalando...');
  
  event.waitUntil(
    caches.open(CACHE_NAME).then(async (cache) => {
      if (DEBUG) console.log('Service Worker: Intentando cachear archivos');
      
      // Páginas críticas que DEBEN cachearse (offline y server-error)
      const criticalUrls = ['/offline.html', '/server-error.html'];
      
      // Intentar cachear páginas críticas primero
      try {
        await cache.addAll(criticalUrls);
        if (DEBUG) console.log('Service Worker: Páginas críticas cacheadas exitosamente');
      } catch (err) {
        console.error('Service Worker: Error crítico - no se pudieron cachear páginas de error', err);
        // No continuar si las páginas críticas no se cachearon
        throw err;
      }
      
      // Cachear el resto de recursos (no críticos)
      const otherUrls = urlsToCache.filter(url => !criticalUrls.includes(url));
      const promises = otherUrls.map(async (url) => {
        try {
          const req = new Request(url, { mode: 'no-cors' });
          const response = await fetch(req);
          if (response) {
            await cache.put(url, response.clone());
            if (DEBUG) console.log('Service Worker: Cacheado', url);
          }
        } catch (err) {
          console.warn('Service Worker: no se pudo cachear', url, err);
        }
      });
      
      await Promise.all(promises);
    })
  );
  
  self.skipWaiting();
});

// Activación del Service Worker
self.addEventListener('activate', (event) => {
  if (DEBUG) console.log('Service Worker: Activando...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Eliminar cachés antiguas
          if (cacheName !== CACHE_NAME) {
            if (DEBUG) console.log('Service Worker: Eliminando caché antigua:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  
  return self.clients.claim();
});

// Interceptar peticiones de red
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // No cachear peticiones no-GET
  if (event.request.method !== 'GET') {
    return;
  }
  
  // No cachear peticiones a otros dominios (excepto APIs específicas)
  if (url.origin !== self.location.origin) {
    // Permitir algunos CDNs específicos
    if (!['cdn.tailwindcss.com', 'unpkg.com', 'fonts.googleapis.com', 'googleapis.com'].some(host => url.hostname.includes(host))) {
      return;
    }
  }
  
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Si está en caché, devolver la versión cacheada
        if (response) {
          return response;
        }
        
        // Si no está en caché, hacer la petición de red
        return fetch(event.request)
          .then((response) => {
            // Manejo de errores HTTP del servidor (5xx, 4xx, etc.)
            if (!response) {
              if (DEBUG) console.warn('Service Worker: Response null', event.request.url);
              return handleRequestError(event.request);
            }
            
            // Si es error 5xx (servidor caído), mostrar página de error del servidor
            if (response.status >= 500) {
              if (DEBUG) console.warn('Service Worker: Error del servidor', response.status, event.request.url);
              if (event.request.destination === 'document') {
                return caches.match('/server-error.html')
                  .then(cachedPage => cachedPage || caches.match('/'))
                  .then(fallback => {
                    // Notificar al cliente sobre el error del servidor
                    notifyClients({
                      type: 'SERVER_ERROR',
                      status: response.status,
                      message: 'El servidor no está disponible en este momento. Mostrando contenido en caché.'
                    });
                    return fallback;
                  });
              }
              return response;
            }
            
            // Si es error 4xx (página no encontrada, etc.), retornar la respuesta tal cual
            if (response.status >= 400) {
              if (DEBUG) console.warn('Service Worker: Error del cliente', response.status, event.request.url);
              return response;
            }
            
            // Verificar que la respuesta es válida (status 200 y tipo correcto)
            if (response.status !== 200 || (response.type !== 'basic' && response.type !== 'cors' && response.type !== 'opaque')) {
              if (DEBUG) console.warn('Service Worker: Response no cacheble', response.status, response.type);
              return response;
            }
            
            // Clonar la respuesta porque es un stream que solo puede leerse una vez
            const responseToCache = response.clone();
            
            // Agregar la respuesta al caché para futuras peticiones (actualizar caché)
            caches.open(CACHE_NAME)
              .then((cache) => {
                cache.put(event.request, responseToCache);
                if (DEBUG) console.log('Service Worker: Actualizado en caché', event.request.url);
              })
              .catch(err => {
                if (DEBUG) console.warn('Service Worker: Error al cachear', err);
              });
            
            return response;
          })
          .catch((error) => {
            // Error de red: no hay conexión o la solicitud fue bloqueada
            if (DEBUG) console.error('Service Worker: Error de red', error, event.request.url);
            return handleRequestError(event.request);
          });
      })
  );
});

// Sincronización en segundo plano
self.addEventListener('sync', (event) => {
  if (DEBUG) console.log('Service Worker: Sincronización en segundo plano', event.tag);
  
  if (event.tag === 'sync-data') {
    event.waitUntil(
      Promise.resolve()
    );
  }
});

// Notificaciones push
self.addEventListener('push', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación push recibida');

  let data = {};
  try {
    data = event.data ? event.data.json() : {};
  } catch (e) {
    console.error('Service Worker: Error al parsear JSON', e);
  }

  const title = data.title || 'Notificación';
  
  const options = {
    body: data.body || 'Nueva notificación',
    icon: data.icon || '{% static "icons/icon-192x192.png" %}',
    badge: data.badge || '{% static "icons/icon-72x72.png" %}',
    image: data.image || undefined,
    data: data.data || {},
    vibrate: data.vibrate || [200, 100, 200],
    actions: data.actions || []
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Click en notificaciones
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = event.notification.data.url || '/';
  
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Buscar si ya hay una ventana abierta con esa URL
      for (let client of clientList) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      // Si no existe, abrir una nueva
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    })
  );
});

// Cierre de notificaciones
self.addEventListener('notificationclose', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación cerrada', event.notification);
});
