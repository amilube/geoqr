{% load static %}
// sw.js - Service Worker para PWA
// {% now "Y-m-d H:i:s" %}
// Permite funcionamiento offline y caché de recursos con Workbox

const CACHE_NAME = '{{ cache_name|default:"geoqr-v2" }}';
const DEBUG = {{ debug|lower }};
const OFFLINE_PAGE = '/offline.html';
const SERVER_ERROR_PAGE = '/server-error.html';

// Importar Workbox desde CDN
importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');

/**
 * Obtiene página de fallback desde caché
 * @param {string} pageUrl - URL de la página de fallback
 * @param {Object} notificationData - Datos para notificar al cliente
 * @returns {Promise<Response>} - Respuesta cacheada o error genérico
 */
async function getFallbackPage(pageUrl, notificationData) {
  try {
    const cache = await caches.open(CACHE_NAME);
    const cachedPage = await cache.match(pageUrl);
    
    if (cachedPage) {
      notifyClients(notificationData);
      return cachedPage;
    }
    
    if (DEBUG) console.error(`Service Worker: ${pageUrl} no está en caché`);
  } catch (err) {
    if (DEBUG) console.error('Service Worker: Error al obtener fallback', err);
  }
  
  // Respuesta de error genérica
  return new Response(notificationData.message || 'Servicio no disponible', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: { 'Content-Type': 'text/plain; charset=utf-8' }
  });
}

/**
 * Notifica a todos los clientes (ventanas/tabs) sobre eventos del Service Worker
 * @param {Object} message - Objeto con información del evento
 */
function notifyClients(message) {
  self.clients.matchAll({ type: 'window' }).then(clients => {
    clients.forEach(client => {
      client.postMessage({
        from: 'ServiceWorker',
        timestamp: new Date().toISOString(),
        ...message
      });
    });
  }).catch(err => {
    if (DEBUG) console.warn('Service Worker: Error al notificar clientes', err);
  });
}


const urlsToCache = [
  // Páginas de error (críticas para funcionar offline)
  OFFLINE_PAGE,
  SERVER_ERROR_PAGE,
  
  // Archivos estáticos
  '{% static "manifest.json" %}',
  '{% static "fallback.css" %}',
  '{% static "app.js" %}',
  
  // Fuentes y librerías externas (se cachean con no-cors)
  'https://cdn.tailwindcss.com',
  'https://unpkg.com/htmx.org@2.0.0',
  'https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js',
  'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap'
];

// CDNs permitidos para cachear
const ALLOWED_CDNS = ['cdn.tailwindcss.com', 'unpkg.com', 'fonts.googleapis.com', 'fonts.gstatic.com'];

// Instalación del Service Worker
self.addEventListener('install', (event) => {
  if (DEBUG) console.log('Service Worker: Instalando...');
  
  event.waitUntil(
    caches.open(CACHE_NAME).then(async (cache) => {
      if (DEBUG) console.log('Service Worker: Intentando cachear archivos');
      
      // Páginas críticas que DEBEN cachearse
      const criticalUrls = [OFFLINE_PAGE, SERVER_ERROR_PAGE];
      
      try {
        await cache.addAll(criticalUrls);
        if (DEBUG) console.log('Service Worker: Páginas críticas cacheadas');
      } catch (err) {
        console.error('Service Worker: Error al cachear páginas críticas', err);
        throw err;
      }
      
      // Cachear recursos no críticos (no bloquean instalación)
      const otherUrls = urlsToCache.filter(url => !criticalUrls.includes(url));
      await Promise.allSettled(
        otherUrls.map(async (url) => {
          try {
            const req = new Request(url, { mode: 'no-cors' });
            const response = await fetch(req);
            if (response) {
              await cache.put(url, response.clone());
              if (DEBUG) console.log('Service Worker: Cacheado', url);
            }
          } catch (err) {
            console.warn('Service Worker: No se pudo cachear', url, err);
          }
        })
      );
    })
  );
  
  self.skipWaiting();
});

// Escuchar mensajes del cliente para activación manual
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Activación del Service Worker
self.addEventListener('activate', (event) => {
  if (DEBUG) console.log('Service Worker: Activando...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter(cacheName => cacheName !== CACHE_NAME)
          .map((cacheName) => {
            if (DEBUG) console.log('Service Worker: Eliminando caché antigua:', cacheName);
            return caches.delete(cacheName);
          })
      );
    }).then(() => self.clients.claim())
  );
});

// Habilitar Navigation Preload si está soportado (mejora rendimiento)
if (workbox.navigationPreload.isSupported()) {
  workbox.navigationPreload.enable();
}

// Estrategia StaleWhileRevalidate de Workbox para recursos estáticos
// Sirve desde caché inmediatamente mientras actualiza en segundo plano
workbox.routing.registerRoute(
  ({ request, url }) => {
    // Solo para recursos del mismo origen o CDNs permitidos
    return url.origin === self.location.origin || 
           ALLOWED_CDNS.some(host => url.hostname.includes(host));
  },
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: CACHE_NAME
  })
);

// Manejo especial para navegación (páginas HTML)
// Este listener implementa la estrategia de Offline Fallback requerida por PWABuilder
self.addEventListener('fetch', (event) => {
  // Solo manejar navegación; Workbox se encarga del resto
  if (event.request.mode !== 'navigate') {
    return;
  }
  
  event.respondWith((async () => {
    try {
      // 1. Intentar usar preloadResponse primero (Navigation Preload)
      const preloadResp = await event.preloadResponse;
      if (preloadResp) {
        if (DEBUG) console.log('Service Worker: Usando preload response');
        // Cachear la respuesta exitosa
        const cache = await caches.open(CACHE_NAME);
        cache.put(event.request, preloadResp.clone());
        return preloadResp;
      }

      // 2. Hacer fetch a la red
      const networkResp = await fetch(event.request);
      
      // 3. Validar respuesta
      if (!networkResp || networkResp.status >= 500) {
        throw new Error(`Server error: ${networkResp?.status || 'No response'}`);
      }
      
      // 4. Cachear la página navegada exitosamente
      if (networkResp.ok) {
        const cache = await caches.open(CACHE_NAME);
        cache.put(event.request, networkResp.clone());
        if (DEBUG) console.log('Service Worker: Página cacheada', event.request.url);
      }
      
      return networkResp;
    } catch (error) {
      // Error de red o servidor caído - OFFLINE SUPPORT
      if (DEBUG) console.error('Service Worker: Error en navegación', error);
      
      const cache = await caches.open(CACHE_NAME);
      
      // Estrategia de fallback en cascada (requerida por PWABuilder)
      // 1. Intentar servir la página específica desde caché
      const cachedResp = await cache.match(event.request);
      if (cachedResp) {
        notifyClients({
          type: 'SERVING_CACHED',
          message: 'Mostrando versión en caché de la página'
        });
        return cachedResp;
      }
      
      // 2. Determinar si es offline o error del servidor
      const isOffline = !navigator.onLine;
      const fallbackPage = isOffline ? OFFLINE_PAGE : SERVER_ERROR_PAGE;
      const notificationType = isOffline ? 'OFFLINE' : 'SERVER_ERROR';
      const notificationMessage = isOffline 
        ? 'No hay conexión a internet. Mostrando página offline.'
        : 'El servidor no está disponible. Mostrando página de error.';
      
      // 3. Servir página de fallback (offline.html o server-error.html)
      return getFallbackPage(fallbackPage, {
        type: notificationType,
        message: notificationMessage
      });
    }
  })());
});

// Sincronización en segundo plano (Background Sync)
self.addEventListener('sync', (event) => {
  if (DEBUG) console.log('Service Worker: Sincronización en segundo plano', event.tag);
  
  if (event.tag === 'sync-data') {
    event.waitUntil(syncData());
  }
});

/**
 * Sincronización de datos cuando hay conexión
 */
async function syncData() {
  try {
    // Aquí puedes implementar lógica de sincronización
    // Por ejemplo, enviar datos guardados offline al servidor
    if (DEBUG) console.log('Service Worker: Sincronizando datos...');
    
    // Notificar a los clientes que la sincronización terminó
    notifyClients({
      type: 'SYNC_COMPLETE',
      message: 'Datos sincronizados exitosamente'
    });
  } catch (error) {
    if (DEBUG) console.error('Service Worker: Error en sincronización', error);
    throw error; // Reintentar sync
  }
}

// Sincronización periódica (Periodic Sync)
self.addEventListener('periodicsync', (event) => {
  if (DEBUG) console.log('Service Worker: Sincronización periódica', event.tag);
  
  if (event.tag === 'content-sync') {
    event.waitUntil(periodicSync());
  }
});

/**
 * Sincronización periódica de contenido
 * Se ejecuta automáticamente en intervalos definidos por el navegador
 */
async function periodicSync() {
  try {
    if (DEBUG) console.log('Service Worker: Ejecutando sincronización periódica...');
    
    // Actualizar caché con contenido nuevo del servidor
    const cache = await caches.open(CACHE_NAME);
    
    // URLs a actualizar periódicamente
    const urlsToUpdate = [
      '/',
      '/offline.html',
      '/server-error.html'
    ];
    
    for (const url of urlsToUpdate) {
      try {
        const response = await fetch(url);
        if (response.ok) {
          await cache.put(url, response);
          if (DEBUG) console.log('Service Worker: Actualizado en caché periódica', url);
        }
      } catch (err) {
        if (DEBUG) console.warn('Service Worker: No se pudo actualizar', url, err);
      }
    }
    
    notifyClients({
      type: 'PERIODIC_SYNC_COMPLETE',
      message: 'Contenido actualizado en segundo plano'
    });
  } catch (error) {
    if (DEBUG) console.error('Service Worker: Error en sincronización periódica', error);
  }
}

// Notificaciones push
self.addEventListener('push', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación push recibida');

  let data = {};
  try {
    data = event.data ? event.data.json() : {};
  } catch (e) {
    console.error('Service Worker: Error al parsear JSON', e);
  }

  const title = data.title || 'Notificación';
  
  const options = {
    body: data.body || 'Nueva notificación',
    icon: data.icon || '{% static "icons/icon-192x192.png" %}',
    badge: data.badge || '{% static "icons/icon-72x72.png" %}',
    image: data.image || undefined,
    data: data.data || {},
    vibrate: data.vibrate || [200, 100, 200],
    actions: data.actions || []
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Click en notificaciones
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = event.notification.data.url || '/';
  
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Buscar si ya hay una ventana abierta con esa URL
      for (let client of clientList) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      // Si no existe, abrir una nueva
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    })
  );
});

// Cierre de notificaciones
self.addEventListener('notificationclose', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación cerrada', event.notification);
});
