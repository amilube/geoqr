{% load static %}
// sw.js - Service Worker para PWA
// {% now "Y-m-d H:i:s" %}
// Permite funcionamiento offline y caché de recursos con Workbox
//
// OFFLINE STRATEGY: Offline page + Offline copy of pages
// This service worker implements PWABuilder-compatible offline support:
// 1. Caches an offline fallback page during installation
// 2. Attempts to serve pages from network first
// 3. Falls back to cached copies when offline
// 4. Shows offline page when no cached version exists
//
// PWABuilder Detection Requirements Met:
// - ✓ Offline fallback page defined (offlineFallbackPage)
// - ✓ Cached during install event
// - ✓ Served when network fails in fetch event
// - ✓ Navigation requests handled properly

const CACHE_NAME = '{{ cache_name|default:"geoqr-v2" }}';
const DEBUG = {{ debug|lower }};

// Offline page configuration (required for PWABuilder detection)
const offlineFallbackPage = '/offline.html';
const OFFLINE_PAGE = offlineFallbackPage;  // Alias para compatibilidad
const SERVER_ERROR_PAGE = '/server-error.html';

// Rutas que NUNCA deben cachearse (requieren CSRF tokens y autenticación)
// Estas rutas siempre irán directo a la red para evitar problemas con:
// - CSRF tokens que cambian en cada request
// - Sesiones de autenticación
// - Formularios con datos sensibles
// - APIs que requieren tokens frescos
const NEVER_CACHE_PATHS = [
  '/accounts/',           // Django-allauth (login, signup, logout, etc.)
  '/admin/',             // Django admin
  '/api/',               // APIs que requieren autenticación
  '/__debug__/',         // Django debug toolbar
];

// Función para verificar si una URL debe ser excluida del cache
function shouldNeverCache(url) {
  const urlPath = new URL(url).pathname;
  return NEVER_CACHE_PATHS.some(path => urlPath.startsWith(path));
}

// Importar Workbox desde CDN
importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js');

/**
 * Obtiene página de fallback desde caché
 * @param {string} pageUrl - URL de la página de fallback
 * @param {Object} notificationData - Datos para notificar al cliente
 * @returns {Promise<Response>} - Respuesta cacheada o error genérico
 */
async function getFallbackPage(pageUrl, notificationData) {
  try {
    const cache = await caches.open(CACHE_NAME);
    const cachedPage = await cache.match(pageUrl);
    
    if (cachedPage) {
      notifyClients(notificationData);
      return cachedPage;
    }
    
    if (DEBUG) console.error(`Service Worker: ${pageUrl} no está en caché`);
  } catch (err) {
    if (DEBUG) console.error('Service Worker: Error al obtener fallback', err);
  }
  
  // Respuesta de error genérica
  return new Response(notificationData.message || 'Servicio no disponible', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: { 'Content-Type': 'text/plain; charset=utf-8' }
  });
}

/**
 * Notifica a todos los clientes (ventanas/tabs) sobre eventos del Service Worker
 * @param {Object} message - Objeto con información del evento
 */
function notifyClients(message) {
  self.clients.matchAll({ type: 'window' }).then(clients => {
    clients.forEach(client => {
      client.postMessage({
        from: 'ServiceWorker',
        timestamp: new Date().toISOString(),
        ...message
      });
    });
  }).catch(err => {
    if (DEBUG) console.warn('Service Worker: Error al notificar clientes', err);
  });
}


const urlsToCache = [
  // Páginas de error (críticas para funcionar offline)
  OFFLINE_PAGE,
  SERVER_ERROR_PAGE,
  
  // Archivos estáticos
  '{% static "manifest.json" %}',
  '{% static "fallback.css" %}',
  '{% static "app.js" %}',
  
  // Fuentes y librerías externas (se cachean con no-cors)
  'https://cdn.tailwindcss.com',
  'https://unpkg.com/htmx.org@2.0.0',
  'https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js',
  'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap'
];

// CDNs permitidos para cachear
const ALLOWED_CDNS = ['cdn.tailwindcss.com', 'unpkg.com', 'fonts.googleapis.com', 'fonts.gstatic.com'];

// Instalación del Service Worker
self.addEventListener('install', (event) => {
  if (DEBUG) console.log('Service Worker: Instalando...');
  
  event.waitUntil(
    caches.open(CACHE_NAME).then(async (cache) => {
      if (DEBUG) console.log('Service Worker: Intentando cachear archivos');
      
      // Cache offline page first (PWABuilder requirement)
      try {
        await cache.add(offlineFallbackPage);
        if (DEBUG) console.log('Service Worker: Offline page cacheada');
      } catch (err) {
        console.error('Service Worker: Error al cachear offline page', err);
        throw err;
      }
      
      // Páginas críticas adicionales
      const criticalUrls = [SERVER_ERROR_PAGE];
      
      try {
        await cache.addAll(criticalUrls);
        if (DEBUG) console.log('Service Worker: Páginas críticas cacheadas');
      } catch (err) {
        console.error('Service Worker: Error al cachear páginas críticas', err);
      }
      
      // Cachear recursos no críticos (no bloquean instalación)
      const otherUrls = urlsToCache.filter(url => 
        url !== offlineFallbackPage && !criticalUrls.includes(url)
      );
      await Promise.allSettled(
        otherUrls.map(async (url) => {
          try {
            const req = new Request(url, { mode: 'no-cors' });
            const response = await fetch(req);
            if (response) {
              await cache.put(url, response.clone());
              if (DEBUG) console.log('Service Worker: Cacheado', url);
            }
          } catch (err) {
            console.warn('Service Worker: No se pudo cachear', url, err);
          }
        })
      );
    })
  );
  
  self.skipWaiting();
});

// Escuchar mensajes del cliente para activación manual
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Activación del Service Worker
self.addEventListener('activate', (event) => {
  if (DEBUG) console.log('Service Worker: Activando...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter(cacheName => cacheName !== CACHE_NAME)
          .map((cacheName) => {
            if (DEBUG) console.log('Service Worker: Eliminando caché antigua:', cacheName);
            return caches.delete(cacheName);
          })
      );
    }).then(() => self.clients.claim())
  );
});

// Habilitar Navigation Preload si está soportado (mejora rendimiento)
if (workbox.navigationPreload.isSupported()) {
  workbox.navigationPreload.enable();
}

// Estrategia StaleWhileRevalidate de Workbox para recursos estáticos
// Sirve desde caché inmediatamente mientras actualiza en segundo plano
// SOLO para GET requests (no POST, PUT, DELETE que requieren CSRF)
workbox.routing.registerRoute(
  ({ request, url }) => {
    // Solo GET requests
    if (request.method !== 'GET') {
      return false;
    }
    
    // Excluir rutas protegidas
    if (shouldNeverCache(url.href)) {
      return false;
    }
    
    // Solo para recursos del mismo origen o CDNs permitidos
    return url.origin === self.location.origin || 
           ALLOWED_CDNS.some(host => url.hostname.includes(host));
  },
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: CACHE_NAME
  })
);

// Manejo especial para navegación (páginas HTML)
// Offline page + Offline copy of pages strategy (PWABuilder compliant)
// This follows the pattern required by PWABuilder and similar PWA detection tools
self.addEventListener('fetch', (event) => {
  // NUNCA cachear rutas de autenticación, admin, o APIs
  if (shouldNeverCache(event.request.url)) {
    if (DEBUG) console.log('Service Worker: Bypass cache para', event.request.url);
    // Pasar directamente a la red sin cachear
    event.respondWith(fetch(event.request));
    return;
  }

  if (event.request.mode === 'navigate') {
    event.respondWith((async () => {
      try {
        // Try to use preload response first (performance optimization)
        const preloadResp = await event.preloadResponse;

        if (preloadResp) {
          // Cache the preload response for offline access (excepto rutas protegidas)
          if (!shouldNeverCache(event.request.url)) {
            const cache = await caches.open(CACHE_NAME);
            cache.put(event.request, preloadResp.clone());
          }
          return preloadResp;
        }

        // NETWORK FIRST: Siempre intentar red primero para navegación
        const networkResp = await fetch(event.request);
        
        // Cache successful navigation responses for offline access
        // Solo si no es una ruta protegida
        if (networkResp && networkResp.ok && !shouldNeverCache(event.request.url)) {
          const cache = await caches.open(CACHE_NAME);
          cache.put(event.request, networkResp.clone());
        }
        
        return networkResp;
      } catch (error) {
        // Network failed - this is where offline support kicks in
        // First, try to serve a cached copy of the specific page requested
        const cache = await caches.open(CACHE_NAME);
        const cachedPage = await cache.match(event.request);
        
        if (cachedPage) {
          // We have a cached version of this exact page
          notifyClients({
            type: 'SERVING_CACHED',
            message: 'Mostrando versión en caché de la página'
          });
          return cachedPage;
        }
        
        // No cached version exists, fall back to the offline page
        // This is the critical part for PWABuilder detection
        const cachedResp = await cache.match(offlineFallbackPage);
        
        if (cachedResp) {
          notifyClients({
            type: 'OFFLINE',
            message: 'No hay conexión a internet. Mostrando página offline.'
          });
          return cachedResp;
        }
        
        // Last resort: generic error response (should never reach here)
        return new Response('Offline - No cached content available', {
          status: 503,
          statusText: 'Service Unavailable',
          headers: { 'Content-Type': 'text/plain; charset=utf-8' }
        });
      }
    })());
  }
});

// Sincronización en segundo plano (Background Sync)
self.addEventListener('sync', (event) => {
  if (DEBUG) console.log('Service Worker: Sincronización en segundo plano', event.tag);
  
  if (event.tag === 'sync-data') {
    event.waitUntil(syncData());
  }
});

/**
 * Sincronización de datos cuando hay conexión
 */
async function syncData() {
  try {
    // Aquí puedes implementar lógica de sincronización
    // Por ejemplo, enviar datos guardados offline al servidor
    if (DEBUG) console.log('Service Worker: Sincronizando datos...');
    
    // Notificar a los clientes que la sincronización terminó
    notifyClients({
      type: 'SYNC_COMPLETE',
      message: 'Datos sincronizados exitosamente'
    });
  } catch (error) {
    if (DEBUG) console.error('Service Worker: Error en sincronización', error);
    throw error; // Reintentar sync
  }
}

// Periodic Background Sync API
// https://web.dev/periodic-background-sync/
self.addEventListener('periodicsync', (event) => {
  if (DEBUG) console.log('Service Worker: Periodic background sync', event.tag);
  
  if (event.tag === 'content-sync') {
    event.waitUntil(periodicContentSync());
  }
});

/**
 * Sincronización periódica de contenido
 * Se ejecuta automáticamente en intervalos definidos por el navegador
 */
async function periodicContentSync() {
  try {
    if (DEBUG) console.log('Service Worker: Ejecutando sincronización periódica...');
    
    // Actualizar caché con contenido nuevo del servidor
    const cache = await caches.open(CACHE_NAME);
    
    // URLs a actualizar periódicamente
    const urlsToUpdate = [
      '/',
      offlineFallbackPage,
      SERVER_ERROR_PAGE
    ];
    
    for (const url of urlsToUpdate) {
      try {
        const response = await fetch(url);
        if (response.ok) {
          await cache.put(url, response);
          if (DEBUG) console.log('Service Worker: Actualizado en caché periódica', url);
        }
      } catch (err) {
        if (DEBUG) console.warn('Service Worker: No se pudo actualizar', url, err);
      }
    }
    
    notifyClients({
      type: 'PERIODIC_SYNC_COMPLETE',
      message: 'Contenido actualizado en segundo plano'
    });
  } catch (error) {
    if (DEBUG) console.error('Service Worker: Error en sincronización periódica', error);
  }
}

// Notificaciones push
self.addEventListener('push', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación push recibida');

  let data = {};
  try {
    data = event.data ? event.data.json() : {};
  } catch (e) {
    console.error('Service Worker: Error al parsear JSON', e);
  }

  const title = data.title || 'Notificación';
  
  const options = {
    body: data.body || 'Nueva notificación',
    icon: data.icon || '/static/icons/android/android-launchericon-192-192.png',
    badge: data.badge || '/static/icons/qeoqr_icon_monochrome.svg',
    image: data.image || undefined,
    data: data.data || {},
    vibrate: data.vibrate || [200, 100, 200],
    actions: data.actions || []
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Click en notificaciones
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const data = event.notification.data || {};
  const targetUrl = data.url || '/';
  const origin = data.origin || self.location.origin;
  const protocolUrl = data.protocolUrl;
  
  if (DEBUG) console.log('Service Worker: Notification click', { protocolUrl, targetUrl, origin });
  
  event.waitUntil(
    clients.matchAll({ 
      type: 'window',
      includeUncontrolled: true 
    }).then((clientList) => {
      // Primero intentar enfocar cualquier cliente existente del mismo origen
      for (let client of clientList) {
        if (client.url.startsWith(origin) && 'focus' in client) {
          if (DEBUG) console.log('Service Worker: Enfocando cliente existente', client.url);
          // Si hay una ruta específica, navegar a ella
          if (targetUrl !== '/') {
            client.postMessage({
              type: 'NAVIGATE',
              url: targetUrl
            });
          }
          return client.focus();
        }
      }
      
      // Si no hay cliente existente, intentar usar protocol handler primero
      if (clients.openWindow) {
        // En PWAs instaladas, el protocol handler funciona mejor para deep linking
        const urlToOpen = protocolUrl || (origin + targetUrl);
        if (DEBUG) console.log('Service Worker: Abriendo', urlToOpen);
        
        return clients.openWindow(urlToOpen).catch((error) => {
          // Fallback a URL normal si el protocol handler falla
          if (DEBUG) console.log('Service Worker: Protocol handler falló, usando URL normal', error);
          return clients.openWindow(origin + targetUrl);
        });
      }
    })
  );
});

// Cierre de notificaciones
self.addEventListener('notificationclose', (event) => {
  if (DEBUG) console.log('Service Worker: Notificación cerrada', event.notification);
});
